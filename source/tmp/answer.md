1. HashMap

    底层 Node 数组 + 链表，满足条件时，链表树化为红黑树

    关键成员变量有 capacity、threshold、loadFactor
    容量2的n次幂，保证哈希函数迅速，扩容简单。

    首次putVal时，在resize中进行实际初始化。

    putVal过程：高位右移计算哈希，& 运算找到哈希桶，根据Key值，寻找空位插入或替换。
    
    树则红黑树插入，否则链表插入，过长则树化。

    扩容过程：与初始化过程耦合。
    未超过最大值时，容量扩大两倍。
    重新哈希，以链表方式遍历哈希桶，拆分为高位地位两个链表。树则拆分树，以及是否重新树化。

2. ConcurrentHashMap

    底层 Node 数组 + 链表，满足条件时，链表树化为红黑树

    负载因子固定为 0.75，首次put时，initTable()初始化，sizeCtl 控制，单线程扩容。

    节点类型有四种，普通链表节点、TreeNode(TreeBin，Node数组通过TreeBin持有红黑树)，ForwardingNode，ReservationNode

    集合写元素时，会加锁，不会出现写写冲突。红黑树的读写冲突，但链表读与红黑树写不冲突。
    扩容时，读取未迁移到的节点，可正常读取。读取正在迁移的节点，因为迁移是复制了原节点中的值，所以可正常读取。读取迁移过的节点，通过转发节点到新数组读取。在未迁移处写入，获取锁后可正常写。在正在迁移的地方，需要等待迁移完毕，锁释放。

    添加元素过程：
        1. 未初始化，初始化。
        2. 哈希桶空的，插入。
        3. 若是转发结点，帮助扩容。
        4. 否则，开始循环找合适的位置，插入。
        5. 插入完成后，判断是否需要扩容。
        6. 若需要扩容时，有人扩容就加入，不然就自己开始。

3. GC 调优

    CMS：
        concurrent mode failure 问题
            原因：1. 新生代晋升速率过快 2. 老年代碎片化严重
            解决方案：
            1. - 调大新生代空间或提高新生代晋升阈值 - 提前老年代垃圾收集时机（-XX:CMSInitiatingOccupancyFraction=68 （默认是 68））
            2. - 增大老年代空间 - -XX:CMSFullGCBeforeCompaction=n 在进行 n 次，CMS 后，进行一次压缩的 Full GC，用以减少 CMS 产生的碎片


4. G1 垃圾收集


sql 挑选索引注意点：

1. 索引列尽量小
2. 索引字符串值对前缀建立索引，但不支持索引排序
3. 索引列单独出现，不用表达式
4. 考虑列的基数
5. 只对where、排序、分组列做索引

使用注意：

1. 过滤过、排序过的数据，不能再次使用二级索引，没有意义；
2. id 尽量自增
3. 避免冗余索引
4. 避免select *，表结构会变，无法使用索引，join时会把查询列和过滤列放入join buffer中

评论服务：

1. 数据量过大 sharding-jdbc 分库分表
2. 写入性能 消息队列
3. 读取性能 联合索引 缓存