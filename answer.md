1. HashMap

    底层 Node 数组 + 链表，满足条件时，链表树化为红黑树

    关键成员变量有 capacity、threshold、loadFactor
    容量2的n次幂，保证哈希函数迅速，扩容简单。

    首次putVal时，在resize中进行实际初始化。

    putVal过程：高位右移计算哈希，& 运算找到哈希桶，根据Key值，寻找空位插入或替换。
    
    树则红黑树插入，否则链表插入，过长则树化。

    扩容过程：与初始化过程耦合。
    未超过最大值时，容量扩大两倍。
    重新哈希，以链表方式遍历哈希桶，拆分为高位地位两个链表。树则拆分树，以及是否重新树化。

2. ConcurrentHashMap

    底层 Node 数组 + 链表，满足条件时，链表树化为红黑树

    负载因子固定为 0.75，首次put时，initTable()初始化，sizeCtl 控制，单线程扩容。

    节点类型有四种，普通链表节点、TreeNode(TreeBin，Node数组通过TreeBin持有红黑树)，ForwardingNode，ReservationNode

    集合写元素时，会加锁，不会出现写写冲突。红黑树的读写冲突，但链表读与红黑树写不冲突。
    扩容时，读取未迁移到的节点，可正常读取。读取正在迁移的节点，因为迁移是复制了原节点中的值，所以可正常读取。读取迁移过的节点，通过转发节点到新数组读取。在未迁移处写入，获取锁后可正常写。在正在迁移的地方，需要等待迁移完毕，锁释放。

    添加元素过程：
        1. 未初始化，初始化。
        2. 哈希桶空的，插入。
        3. 若是转发结点，帮助扩容。
        4. 否则，开始循环找合适的位置，插入。
        5. 插入完成后，判断是否需要扩容。
        6. 若需要扩容时，有人扩容就加入，不然就自己开始。

